/* Generated By:JavaCC: Do not edit this line. OntoLang.java */

/*
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version. You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

package org.UoR.ontolang;


import java.io.*;
import java.util.*;

//Libraries used to communicate with ontologies.
import edu.stanford.smi.protege.model.KnowledgeBase;
import edu.stanford.smi.protege.model.*;

public class OntoLang implements OntoLangConstants {
        public static class Types
        {
                public static final int CLS = 0;
                public static final int SLOT = 1;
                public static final int INS = 2;
        }

        private String thatReturn="";

        private int investigateType;
        private ArrayList ONTresult;


        private KnowledgeBase kb;
        private SystemFrames systemframes;
        private Random rand;

        //Default string to use with the parser
        private String defaultStrings[];

    /**An unknown AIML input*/
    protected static final String O_UNKNOWN = "UNKNOWN";

    public OntoLang(KnowledgeBase kb)
    {
        this(new StringReader("test"));
                this.kb = kb;

                Long seed = System.nanoTime();
                this.rand = new Random(seed);

                defaultStrings = new String[3];
                defaultStrings[Types.CLS] = ":NAME";
                defaultStrings[Types.SLOT]= ":NAME";
                defaultStrings[Types.INS] = ":NAME";

                systemframes = kb.getSystemFrames();
    }

    public void setDefaultInstanceString(String instanceString)
    {
        defaultStrings[Types.INS] = instanceString;
    }

        public String getOntologyResponse(String input) throws ParseException
        {
                ONTresult = new ArrayList();
                StringReader inp = new StringReader(input);
                this.ReInit(inp);
                String res = this.OntQue();
                return res;
        }

        /**
	 * Gets collection of instances (Cls, Instance or Slot) satisfying the predicate
	 * slotName: name of slot used to identify Cls. If null cls found by their defaultName.
	 * cType: Token storing comparison knowledge
	 * slotValue: Value which is used to check against
	*/
        private Collection getCLSes(String slotName,Token cType,String slotValue) throws ParseException
        {
                //Find all Cls'es, which are equal to slotValue
                Collection possibles;
                Iterator iPos;

                boolean check;
                if (cType.image.equals("==")| cType.image.equals("+="))
                        check=true;
                else
                        check=false;

                if(slotName==null)
                {
                        possibles = new ArrayList();
                        Cls c = kb.getCls(slotValue);
                        if(c!=null) possibles.add(c);
                }
                else
                {
                        Collection allClses = kb.getClses();
                        possibles = new ArrayList();
                        iPos = allClses.iterator();
                        while(iPos.hasNext())
                        {
                                Cls c=(Cls)iPos.next();
                                String val=getSlotVal(c,slotName);
                                if ((val.equals(slotValue) & check) | (!val.equals(slotValue) & !check)) collectionAdd(possibles,c);
                        }
                }

                //Holds all cls, which have been removed during negation.
                //Used to find instances
                Collection removeCls = new ArrayList();

                //Get inverse set if it is a neg. predicate.
                if(!check & (slotName==null))
                {
                        Collection allCls = kb.getClses();
                        iPos = possibles.iterator();
                        while(iPos.hasNext())
                        {
                                Cls c=(Cls)iPos.next();
                                String val;
                                val=getSlotVal(c,slotName);
                                if(val!=slotValue)
                                {
                                        //if (investigateType==Types.INS) allCls.removeAll(c.getSuperclasses());

                                        allCls.remove(c);
                                        removeCls.add(c);
                                }
                        }
                        possibles=allCls;
                }

                //Add sub-Cls to possibles
                if(cType.image.equals("+=") & (investigateType!=Types.INS))
                {
                        Collection subClses = new ArrayList();
                        iPos = possibles.iterator();
                        while(iPos.hasNext())
                        {
                                Cls c = (Cls)iPos.next();
                                subClses.addAll(c.getSubclasses());
                        }
                        possibles.addAll(subClses);
                }

                ArrayList results = new ArrayList();
                //Return correct type.
                switch (investigateType)
                {
                        case Types.CLS:
                                return possibles;
                        case Types.SLOT:
                                iPos = possibles.iterator();
                                while(iPos.hasNext())
                                {
                                        Cls c = (Cls)iPos.next();
                                        collectionAddAll(results, c.getTemplateSlots());
                                        //collectionAddAll(c.getOwnSlots()); ONTSLOT should only return template slots
                                }
                                return results;
                        case Types.INS:
                                //removeSuperCls(possibles);
                                iPos = possibles.iterator();
                                while(iPos.hasNext())
                                {
                                        Cls c = (Cls)iPos.next();
                                        collectionAddAll(results, c.getInstances());
                                }
                                iPos = removeCls.iterator();
                                while(iPos.hasNext())
                                {
                                        Cls c = (Cls)iPos.next();
                                        results.removeAll(c.getDirectInstances());
                                }
                                return results;
                        default:
                                throw new ParseException("Illigal investigation type in cls call");
                }
        }


        /**
	 * Gets collection of instances (Cls, Instance or Slot) satisfying the predicate
	 * slotName: Name of slot to check for equality. If null the get default value.
	 * cType: Can be equal-to or not-equal-to token
	 * slotValue: Value which is used to check against
	 * eType: If null then no instance check is performed, else if it is an ONTINS query instances in the domain is check to satisfy the folowing predicate.
	 * insSlotName: The Slot of the instance to use in the check. If null use default value or toString() if not ValueType.INSTANCE
	 * insType: Type of check. equal-to, not-equal-to
	 * insValue: Value to check against.
	*/
        private Collection getSLOTs(String slotName,Token cType,String slotValue,Token eType, String insSlotName, Token insCheckType, String insValue) throws ParseException
        {
                //Find all Slots, which are equal to slotValue
                Collection possibles;
                Iterator iPos;

                boolean check;
                if (cType.image.equals("=="))
                        check=true;
                else
                        check=false;

                if(slotName==null)
                {
                        possibles = new ArrayList();
                        Slot s = kb.getSlot(slotValue);
                        if (s!=null) possibles.add(s);
                }
                else
                {
                        Collection allSlots = kb.getSlots();
                        allSlots.removeAll(kb.getSubclasses(kb.getRootSlotMetaCls()));
                        possibles = new ArrayList();
                        iPos = allSlots.iterator();
                        while(iPos.hasNext())
                        {
                                Slot s=(Slot)iPos.next();
                                String val=getSlotVal(s,slotName);
                                if ((val.equals(slotValue) & check) | (!val.equals(slotValue) & !check)) collectionAdd(possibles,s);
                        }
                        //if (investigateType==Types.INS) removeSuperCls(possibles);
                }

                //Get inverse set if it is a neg. predicate.
                if(!check & (slotName==null))
                {
                        Collection allSlots = kb.getSlots();
                        allSlots.removeAll(kb.getSubclasses(kb.getRootSlotMetaCls()));
                        iPos = possibles.iterator();
                        while(iPos.hasNext())
                        {
                                Slot s=(Slot)iPos.next();
                                String val;
                                val=getSlotVal(s,slotName);
                                if(val!=slotValue)
                                {
                                        //if (investigateType==Types.INS) allSlots.removeAll(c.getSuperclasses());
                                        allSlots.remove(s);
                                }
                        }
                        possibles=allSlots;
                }

                ArrayList results = new ArrayList();
                Collection allSlots;
                iPos = possibles.iterator();
                //Return correct type.
                switch (investigateType)
                {
                        case Types.CLS:
                                while(iPos.hasNext())
                                {
                                        Slot s = (Slot)iPos.next();
                                        collectionAddAll(results,s.getDomain());
                                }
                                return results;
                        case Types.SLOT:
                                return possibles;
                        case Types.INS:
                                Collection domainCls = new ArrayList();
                                while(iPos.hasNext())
                                {
                                        Slot s = (Slot)iPos.next();
                                        collectionAddAll(domainCls,s.getDomain());
                                }
                                iPos = domainCls.iterator();
                                while(iPos.hasNext())
                                {
                                        Cls c = (Cls)iPos.next();
                                        collectionAddAll(results,c.getInstances());
                                }
                                if(eType==null) return results;

                                iPos = results.iterator();
                                Collection insResults = new ArrayList();

                                while(iPos.hasNext())
                                {
                                        Instance c = (Instance)iPos.next();

                                        Collection vals = new ArrayList();

                                        Iterator iSlots = possibles.iterator();
                                        while(iSlots.hasNext())
                                        {
                                                Slot sl = (Slot)iSlots.next();
                                                if (c instanceof Cls)
                                                        collectionAddAll(vals,((Cls)c).getTemplateSlotValues(sl));

                                                collectionAddAll(vals,c.getOwnSlotValues(sl));
                                        }

                                        //TODO: Incorporate a way to control whether unknown values are allowed.
                                        //They aren't now
                                        if((vals.size()==0)& (!check|(insValue.equals(""))))
                                        {
                                                collectionAdd(insResults,c);
                                                continue;
                                        }

                                        if(insSlotName=="" | insSlotName==null) insSlotName=defaultStrings[Types.INS];
                                        iSlots = vals.iterator();
                                        while(iSlots.hasNext())
                                        {
                                                Object o = iSlots.next();
                                                String val;
                                                if(o instanceof Instance)
                                                        val = getSlotVal((Instance)o,insSlotName);
                                                else
                                                        val = o.toString();

                                                boolean strEqual = val.equals(insValue);
                                                boolean eqSign = false;

                                                if(insCheckType.image.equals("=="))
                                                        eqSign=true;
                                                if ((strEqual & eqSign)|(!strEqual & !eqSign))
                                                {
                                                        collectionAdd(insResults, c);
                                                        break;
                                                }
                                        }
                                }
                                return insResults;
                        default:
                                throw new ParseException("Illigal investigation type in slot call");
                }
        }

        /**
	 * Gets collection of instances (Cls, Instance or Slot) satisfying the predicate
	 * slotName: Name of slot to check for equality. If null the get default value.
	 * cType: Token storing comparison knowledge
	 * slotValue: Value which is used to check against
	*/
        private Collection getINSes(String slotName,Token cType,String slotValue) throws ParseException
        {
                //Find all instances, which are equal to slotValue
                Collection possibles = new ArrayList();
                Iterator iPos;

                boolean check;
                if (cType.image.equals("=="))
                        check=true;
                else
                        check=false;

                if(slotName==null)
                        slotName = new String(defaultStrings[Types.INS]);
                if(slotName.equals("")) slotName = defaultStrings[Types.INS];

                Collection allIns = kb.getInstances(kb.getRootCls());
                allIns.removeAll(kb.getInstances(kb.getRootClsMetaCls()));

                iPos = allIns.iterator();
                while(iPos.hasNext())
                {
                        Instance i=(Instance)iPos.next();
                        String val;
                        val=getSlotVal(i,slotName);
                        if(val.equals(slotValue)) collectionAdd(possibles,i);
                }

                if(!check & (investigateType==Types.CLS))
                {
                        Collection results = kb.getClses();
                        iPos = possibles.iterator();
                        while(iPos.hasNext())
                        {
                                Instance i = (Instance)iPos.next();
                                results.remove(i.getDirectType());
                        }
                        return results;
                }
                if(!check)
                {
                        iPos = possibles.iterator();
                        while(iPos.hasNext())
                        {
                                Instance i = (Instance)iPos.next();
                                allIns.remove(i);
                        }
                        possibles = allIns;
                }

                switch (investigateType)
                {
                        case Types.CLS:
                                Collection results = new ArrayList();
                                iPos = possibles.iterator();
                                while(iPos.hasNext())
                                {
                                        Instance i = (Instance)iPos.next();
                                        collectionAdd(results,i.getDirectType());
                                }
                                return results;
                        case Types.SLOT:
                                //TODO: find a functionality
                                return new ArrayList();
                        case Types.INS:
                                return possibles;
                        default:
                                throw new ParseException("Illigal investigation type in ins call");
                }
        }

        /**
	 * Gets collection of instances (Cls, Instance or Slot) satisfying the predicate
	*/
        private Collection getFCTs(Token cType,String slotValue,Token type) throws ParseException
        {
                //Throw exception if not (slotValue XOR type)
                if((slotValue==null && type==null) || (slotValue!=null && type!=null))
                        throw new ParseException("Designer ERROR: slotValue XOR type not satisfied.");

                //Returns empty Collection is a ins or cls is expected return type.
                if(investigateType==Types.INS || investigateType==Types.CLS) return new ArrayList();

                //Find all Slots, which are equal to slotValue or type
                Collection possibles = kb.getSlots();
                Iterator iPos = possibles.iterator();

                Collection results = new ArrayList();

                boolean equal;
                if(cType.image.equals("=="))
                        equal=true;
                else
                        equal=false;

                while(iPos.hasNext())
                {
                        Slot s = (Slot)iPos.next();
                        boolean slotAllowsValue;

                        if(slotValue==null)
                        {
                                slotAllowsValue = ((s.getValueType()==ValueType.INSTANCE) & type.image.equals("INSTANCE")) |
                                                                        ((s.getValueType()!=ValueType.INSTANCE) & !type.image.equals("INSTANCE"));

                        }
                        else
                        {
                                Cls c = kb.getCls(slotValue);
                                slotAllowsValue = s.getAllowedClses().contains(c);
                        }

                        if ((slotAllowsValue & equal) | (!slotAllowsValue & !equal)) results.add(s);
                }

                switch (investigateType)
                {
                        case Types.CLS:
                                throw new ParseException("Illigal investigation type in ins call");
                        case Types.SLOT:
                                return results;
                        case Types.INS:
                                throw new ParseException("Illigal investigation type in ins call");
                        default:
                                throw new ParseException("Illigal investigation type in ins call");
                }
        }

        /**
	 * Gets a single instance (Cls, Instance or Slot) from a Collection
	*/
        private Object getSingleObject(Collection possibleInstances)
        {
        Object winner = null;;

                if (possibleInstances.size()!=0)
                {
                Object [] res = possibleInstances.toArray();
                        winner = res[this.rand.nextInt(possibleInstances.size())];
        }

                return winner;
    }

    private void collectionAdd(Collection col, Object o)
    {
        if(!col.contains(o)) col.add(o);
    }

    private void collectionAddAll(Collection col, Collection in)
    {
        Iterator i = in.iterator();
        while(i.hasNext())
        {
                Object o = i.next();
                if(!col.contains(o)) col.add(o);
        }
    }

    //Removes META-CLS from collection
    //TODO: incorporate functionality to choose META data
    private void removeMetaData(Collection col)
    {
                /*col.removeAll(kb.getSubclasses(kb.getRootClsMetaCls()));
		col.removeAll(kb.getSubclasses(kb.getRootFacetMetaCls()));
		col.removeAll(kb.getSubclasses(kb.getRootSlotMetaCls()));
		col.remove(kb.getRootClsMetaCls());
		col.remove(kb.getRootFacetMetaCls());
		col.remove(kb.getRootClsMetaCls());*/
                col.removeAll(systemframes.getFrames());
    }

    private void removeSuperCls(Collection col)
    {
        Collection superCls = new ArrayList();

        Iterator iCol = col.iterator();
        while(iCol.hasNext())
        {
                Cls c = (Cls)iCol.next();
                superCls.addAll(c.getSuperclasses());
        }

        iCol = col.iterator();
        while(iCol.hasNext())
        {
                Cls c = (Cls)iCol.next();
                if (superCls.contains(c)) iCol.remove();
        }
    }

    private String getSlotVal(Frame fr,String slotName) throws ParseException
    {
        if (slotName==null) slotName="";
        if(slotName=="")
        {
                if(fr instanceof Cls)
                        slotName=defaultStrings[Types.CLS];
                else
                        if(fr instanceof Slot)
                                slotName=defaultStrings[Types.SLOT];
                        else
                                if(fr instanceof Instance)
                                        slotName=defaultStrings[Types.INS];
                                else
                                        throw new ParseException("Return type mismatch.");
        }

                Collection slots = kb.getSlots();
                Iterator iSlots = slots.iterator();
                while(iSlots.hasNext())
                {
                        Slot s = (Slot)iSlots.next();
                        String name = s.getName();
                        if(name.equals(slotName))
                        {
                                if (fr instanceof Cls)
                                {
                                        Cls c = (Cls)fr;
                                        if (kb.hasTemplateSlot(c,s) & !kb.hasOwnSlot(c,s))
                                        {
                                                if (c.getTemplateSlotValueType(s)==ValueType.INSTANCE)
                                                {
                                                Instance i = (Instance)c.getTemplateSlotValue(s);
                                                return (String)i.getOwnSlotValue(kb.getSlot(defaultStrings[Types.INS]));
                                        }
                                        else
                                        {
                                                Object o = c.getTemplateSlotValue(s);
                                                if(o==null) return "";
                                                return o.toString();
                                        }
                                }
                                }
                                if (kb.hasOwnSlot(fr,s))
                                {
                                        if (fr.getOwnSlotValueType(s)==ValueType.INSTANCE)
                                        {
                                        Instance i = (Instance)fr.getOwnSlotValue(s);
                                        return (String)i.getOwnSlotValue(kb.getSlot(defaultStrings[Types.INS]));
                                }
                                else
                                {
                                        Object o = fr.getOwnSlotValue(s);
                                        if(o==null) return "";
                                        return o.toString();
                                }
                        }

                }
        }
        return O_UNKNOWN;
    }

        private String getStringToken(Token t)
        {
                return t.image.substring(1,t.image.length()-1);
        }

        private int getNumberToken(Token t)
        {
                return Integer.parseInt(t.image.substring(1));
        }

        public String getThatReturn()
        {
                return this.thatReturn;
        }

        private Collection collectionXOR(Collection pos1, Collection pos2)
        {
                Collection XORcol = new ArrayList();
                Collection dummy = new ArrayList();

                dummy.addAll(pos2);
                dummy.removeAll(pos1);

                XORcol.addAll(dummy);

                dummy.clear();
                dummy.addAll(pos1);
                dummy.removeAll(pos2);

                XORcol.addAll(dummy);

                return XORcol;
        }

  final public String OntQue() throws ParseException {
        String res;
    jj_consume_token(ONTQUE);
    res = CommandList();
    ThatReturnPart();
    jj_consume_token(0);
                {if (true) return "ONTQUE " + res;}
    throw new Error("Missing return statement in function");
  }

//Returns the strin
  final public String CommandList() throws ParseException {
        String res,r1;
    jj_consume_token(LPAREN);
    res = CommandPart();
    label_1:
    while (true) {
      if (jj_2_1(3)) {
        ;
      } else {
        break label_1;
      }
      r1 = CommandPart();
                                                       res+=" "+r1;
    }
    jj_consume_token(RPAREN);
                {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

//Initiates the Collection to find depending on command
//Return a string with "<command-type> <single-fit from all possible>"
  final public String CommandPart() throws ParseException {
        String res,resIns;
        String slotString="";
        Collection possibles = new ArrayList();
    res = Command();
    possibles = PredicateStatement();
    if (jj_2_2(3)) {
      slotString = ColonString();
    } else {
      ;
    }
                //if(investigateType == Types.CLS) possibles.removeAll(kb.getSubclasses(kb.getRootClsMetaCls()));
                Object o = getSingleObject(possibles);

                if(o!=null)
                        resIns = getSlotVal((Frame)o,slotString);
                else
                        resIns = O_UNKNOWN;

                ONTresult.add(resIns);
                res +=" " + resIns;
                {if (true) return res;}
    throw new Error("Missing return statement in function");
  }

//Returns all frames of the given type
  final public String Command() throws ParseException {
        Token t;
    if (jj_2_3(3)) {
      t = jj_consume_token(ONTCLS);
                this.investigateType = Types.CLS;
                {if (true) return t.image;}
    } else if (jj_2_4(3)) {
      t = jj_consume_token(ONTINS);
                this.investigateType = Types.INS;
                {if (true) return t.image;}
    } else if (jj_2_5(3)) {
      t = jj_consume_token(ONTSLT);
                this.investigateType = Types.SLOT;
                {if (true) return t.image;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//Return Collection of possibles using logic between predicates
  final public Collection PredicateStatement() throws ParseException {
        Collection pos;
    jj_consume_token(LPAREN);
    pos = PredicateList();
    jj_consume_token(RPAREN);
                {if (true) return pos;}
    throw new Error("Missing return statement in function");
  }

  final public Collection PredicateList() throws ParseException {
        Collection pos;
    pos = PredicateXOR();
                {if (true) return pos;}
    throw new Error("Missing return statement in function");
  }

  final public Collection PredicateXOR() throws ParseException {
        Collection pos1 = null;
        Collection pos2 = null;
        Collection mpos = null;
    pos1 = PredicateOR();
    label_2:
    while (true) {
      if (jj_2_6(3)) {
        ;
      } else {
        break label_2;
      }
      jj_consume_token(SC_XOR);
      pos2 = PredicateOR();
                                                          if(mpos==null) mpos=pos2; else mpos=collectionXOR(mpos,pos2);
    }
                if(mpos==null) {if (true) return pos1;}
                pos1 = collectionXOR(pos1,mpos);
                {if (true) return pos1;}
    throw new Error("Missing return statement in function");
  }

  final public Collection PredicateOR() throws ParseException {
        Collection pos1 = null;
        Collection pos2 = null;
        Collection mpos = null;
    pos1 = PredicateAND();
    label_3:
    while (true) {
      if (jj_2_7(3)) {
        ;
      } else {
        break label_3;
      }
      jj_consume_token(SC_OR);
      pos2 = PredicateAND();
                                                           if(mpos==null) mpos=pos2; else mpos.addAll(pos2);
    }
                if(mpos==null) {if (true) return pos1;}

                pos1.addAll(mpos);
                {if (true) return pos1;}
    throw new Error("Missing return statement in function");
  }

  final public Collection PredicateAND() throws ParseException {
        Collection pos1 = null;
        Collection pos2 = null;
        Collection mpos = null;
    pos1 = PredicateUNARY();
    label_4:
    while (true) {
      if (jj_2_8(3)) {
        ;
      } else {
        break label_4;
      }
      jj_consume_token(SC_AND);
      pos2 = PredicateUNARY();
                                                                if(mpos==null) mpos=pos2; else mpos.retainAll(pos2);
    }
                if(mpos==null) {if (true) return pos1;}

                pos1.retainAll(mpos);
                {if (true) return pos1;}
    throw new Error("Missing return statement in function");
  }

  final public Collection PredicateUNARY() throws ParseException {
        Collection pos;
    if (jj_2_9(3)) {
      pos = Predicate();
                removeMetaData(pos);
                {if (true) return pos;}
    } else if (jj_2_10(3)) {
      jj_consume_token(LPAREN);
      pos = PredicateList();
      jj_consume_token(RPAREN);
                //removeMetaData(pos);
                {if (true) return pos;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//Return Collection of possibles
  final public Collection Predicate() throws ParseException {
        Collection pos;

        String slotName=null;
        String slotValue=null;
        String insSlotName=null;
        String insValue=null;

        Token t=null;
        Token cType;
        Token insType=null;
    if (jj_2_18(3)) {
      jj_consume_token(SLOT);
      if (jj_2_11(3)) {
        slotName = ColonString();
      } else {
        ;
      }
      cType = CheckType();
      slotValue = RefOrString();
      if (jj_2_13(3)) {
        t = jj_consume_token(GETINS);
        if (jj_2_12(3)) {
          insSlotName = ColonString();
        } else {
          ;
        }
        insType = CheckType();
        insValue = RefOrString();
      } else {
        ;
      }
                pos=getSLOTs(slotName,cType,slotValue,t,insSlotName, insType, insValue);
                {if (true) return pos;}
    } else if (jj_2_19(3)) {
      jj_consume_token(CLS);
      if (jj_2_14(3)) {
        slotName = ColonString();
      } else {
        ;
      }
      cType = ClsCheckType();
      slotValue = RefOrString();
                pos=getCLSes(slotName,cType,slotValue);
                {if (true) return pos;}
    } else if (jj_2_20(3)) {
      jj_consume_token(INS);
      if (jj_2_15(3)) {
        slotName = ColonString();
      } else {
        ;
      }
      cType = CheckType();
      slotValue = RefOrString();
                pos=getINSes(slotName, cType,slotValue);
                {if (true) return pos;}
    } else if (jj_2_21(3)) {
      jj_consume_token(FCT);
      cType = CheckType();
      if (jj_2_16(3)) {
        slotValue = RefOrString();
      } else if (jj_2_17(3)) {
        t = TypeToken();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
                pos=getFCTs(cType,slotValue,t);
                {if (true) return pos;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token TypeToken() throws ParseException {
        Token t;
    if (jj_2_22(3)) {
      t = jj_consume_token(FCTTYPEINS);
                {if (true) return t;}
    } else if (jj_2_23(3)) {
      t = jj_consume_token(FCTTYPENOTINS);
                {if (true) return t;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token ClsCheckType() throws ParseException {
        Token t;
    if (jj_2_24(3)) {
      t = jj_consume_token(PLUSEQ);
                {if (true) return t;}
    } else if (jj_2_25(3)) {
      t = CheckType();
                {if (true) return t;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public Token CheckType() throws ParseException {
        Token t;
    if (jj_2_26(3)) {
      t = jj_consume_token(EQ);
                {if (true) return t;}
    } else if (jj_2_27(3)) {
      t = jj_consume_token(NE);
                {if (true) return t;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String RefOrString() throws ParseException {
        Token t;
    if (jj_2_28(3)) {
      t = jj_consume_token(STRING);
                {if (true) return getStringToken(t);}
    } else if (jj_2_29(3)) {
      t = jj_consume_token(REFNUMBER);
                int i = getNumberToken(t);
                try
                {
                        String res = (String)ONTresult.get(i-1);
                        {if (true) return res;}
                } catch(IndexOutOfBoundsException ie)
                {
                        {if (true) throw new ParseException("Reference out of bounds. #REF < " + ONTresult.size() + " expected.");}
                }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public String ColonString() throws ParseException {
        Token t;
    jj_consume_token(COLON);
    t = jj_consume_token(STRING);
                {if (true) return getStringToken(t);}
    throw new Error("Missing return statement in function");
  }

  final public void ThatReturnPart() throws ParseException {
        Token t;
    jj_consume_token(THAT);
    jj_consume_token(ASSIGN);
    t = jj_consume_token(STRING);
                this.thatReturn = getStringToken(t);
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  final private boolean jj_3_29() {
    if (jj_scan_token(REFNUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3_29()) return true;
    }
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_scan_token(GETINS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_12()) jj_scanpos = xsp;
    if (jj_3R_12()) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(ONTSLT)) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(SC_AND)) return true;
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(ONTINS)) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_14()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_3R_10()) return true;
    return false;
  }

  final private boolean jj_3R_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_9()) {
    jj_scanpos = xsp;
    if (jj_3_10()) return true;
    }
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) {
    jj_scanpos = xsp;
    if (jj_3_5()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(ONTCLS)) return true;
    return false;
  }

  final private boolean jj_3R_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) return true;
    }
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(SC_OR)) return true;
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_5()) return true;
    return false;
  }

  final private boolean jj_3R_8() {
    if (jj_3R_9()) return true;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_3R_12()) return true;
    return false;
  }

  final private boolean jj_3R_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3_25()) return true;
    }
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_scan_token(PLUSEQ)) return true;
    return false;
  }

  final private boolean jj_3R_5() {
    if (jj_3R_16()) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(SC_XOR)) return true;
    if (jj_3R_7()) return true;
    return false;
  }

  final private boolean jj_3R_7() {
    if (jj_3R_8()) return true;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_scan_token(FCTTYPENOTINS)) return true;
    return false;
  }

  final private boolean jj_3R_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3_23()) return true;
    }
    return false;
  }

  final private boolean jj_3_22() {
    if (jj_scan_token(FCTTYPEINS)) return true;
    return false;
  }

  final private boolean jj_3R_18() {
    if (jj_3R_7()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3_21() {
    if (jj_scan_token(FCT)) return true;
    if (jj_3R_12()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) return true;
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_scan_token(INS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_15()) jj_scanpos = xsp;
    if (jj_3R_12()) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3R_11() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3R_6() {
    if (jj_scan_token(COLON)) return true;
    if (jj_scan_token(STRING)) return true;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_scan_token(CLS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_14()) jj_scanpos = xsp;
    if (jj_3R_15()) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_scan_token(SLOT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) jj_scanpos = xsp;
    if (jj_3R_12()) return true;
    if (jj_3R_13()) return true;
    return false;
  }

  final private boolean jj_3R_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3_19()) {
    jj_scanpos = xsp;
    if (jj_3_20()) {
    jj_scanpos = xsp;
    if (jj_3_21()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_17() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_11()) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_6()) return true;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_6()) return true;
    return false;
  }

  public OntoLangTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[0];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[29];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public OntoLang(java.io.InputStream stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OntoLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public OntoLang(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new OntoLangTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public OntoLang(OntoLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(OntoLangTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 0; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[33];
    for (int i = 0; i < 33; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 0; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 33; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 29; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
